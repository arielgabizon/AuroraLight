\def\notes{1}
\documentclass[11pt]{article}
%\usepackage[T1]{fontenc}
%\usepackage[letterpaper]{geometry}
%\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
%\usepackage{verbatim}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
%\usepackage{setspace}
\usepackage{xspace}%,enumitem}
%\usepackage{times}
\usepackage{fullpage,array}
%\usepackage{hyperref}
%\doublespacing
\usepackage{color}
\usepackage{numdef}
\usepackage{enumitem}
\usepackage{amsopn}
%\usepackage{hyperref} 
\usepackage{mathrsfs}
\usepackage{float}
\restylefloat{table}

\providecommand{\sqbinom}{\genfrac{\lbrack}{\rbrack}{0pt}{}}
\DeclareMathOperator{\spn}{span}

\newif\ifdraft
%\drafttrue
\draftfalse
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
%\numberwithin{equation}{section} %% Comment out for sequentially-numbered
\numberwithin{figure}{section} %% Comment out for sequentially-numbered
\newtheorem{thm}{Theorem}[section]
\newtheorem{conjecture}[thm]{Conjecture}
\newtheorem{definition}[thm]{Definition}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{remark}[thm]{Remark}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{claim}[thm]{Claim}
\newtheorem{fact}[thm]{Fact}
\newtheorem{openprob}[thm]{Open Problem}
\newtheorem{remk}[thm]{Remark}
\newtheorem{example}[thm]{Example}
\newtheorem{apdxlemma}{Lemma}
\newcommand{\question}[1]{{\sf [#1]\marginpar{?}} }
%\usepackage{babel}
\usepackage{tikz}

\makeatletter
\newcommand*{\circled}{\@ifstar\circledstar\circlednostar}
\makeatother

\newcommand*\circledstar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      fill,
      circle,
      minimum size=1.35em,
      text=white,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}
\newcommand*\circlednostar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      draw,
      circle,
      minimum size=1.35em,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}

\providecommand{\bd}[1]{\circled{#1}}


%Eli's macros
\newcommand{\E}{{\mathbb{E}}}
%\newcommand{\N}{{\mathbb{N}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\calF}{{\cal{F}}}
%\newcommand{\inp}[1]{\langle{#1}\rangle}
\newcommand{\disp}[1]{D_{#1}}
%\newcommand{\spn}[1]{{\rm{span}}\left(#1\right)}
%\newcommand{\supp}{{\rm{supp}}}
\newcommand{\agree}{{\sf{agree}}}
\newcommand{\RS}{{\sf{RS}}}
\newcommand{\aRS}{{\sf{aRS}}}
\newcommand{\rrs}{R_{\aRS}}
\newcommand{\VRS}{V_\RS}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\renewcommand{\a}{\ensuremath{\mathbf{a}}\xspace}

\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}
\newcommand{\Y}{\ensuremath{\mathbf{Y}}\xspace}
\newcommand{\y}{\ensuremath{\mathbf{y}}\xspace}

\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\angles}[1]{\langle{#1}\rangle}
\renewcommand{\span}{\ensuremath{\mathsf{span}}\xspace}
\newcommand{\condset}[2]{\set{#1 \mid #2 }}
\newcommand{\zo}{\set{0,1}}
\newcommand{\zon}{{\zo^n}}
\newcommand{\zom}{{\zo^m}}
\newcommand{\zok}{{\zo^}}
\newcommand{\eps}{\epsilon}
\newcommand{\e}{\eps}
%\newcommand{\d}{\delta}
\newcommand{\poly}{\ensuremath{\mathrm{poly}(\lambda)}\xspace}
\newcommand{\itone}{{\it{(i)}}\xspace}
\newcommand{\ittwo}{{\it{(ii)}}\xspace}
\newcommand{\itthree}{{\it{(iii)}}\xspace}
\newcommand{\itfour}{{\it{(iv)}}\xspace}
\newcommand{\cc}{{\rm{CC}}}
\newcommand{\rnk}{{\rm{rank}}}
\newcommand{\T}{T}
\newcommand{\I}{{\mathbb{I}}}
\ifdraft
\newcommand{\ariel}[1]{{\color{blue}{\textit{#1 --- ariel gabizon}}}}
\else
\newcommand{\ariel}[1]{}
\fi
\providecommand{\improvement}[1]{{\color{red} \textbf{#1}}}
\title{%
On the efficiency of pairing-based proofs under the $d$-PKE}
\date{\today}
\author{Ariel Gabizon\thanks{Part of this work was done while being supported by the Zcash Company.}}
\date{}
\begin{document}
\maketitle
 \mathchardef\mhyphen="2D

%\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}

%\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{A'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\abase}{\ensuremath{A_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\bbase}{\ensuremath{B_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\cbase}{\ensuremath{C_{\mathrm{\mathbf{0}}}}\xspace}

\newcommand{\amid}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\bmid}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\cmid}{\ensuremath{C_{\mathrm{mid}}}\xspace}

\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
\newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
\newcommand{\snark}{\ensuremath{\mathscr S}\xspace}
\newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
\newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}

\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\A}{\ensuremath{\vec{A}}\xspace}
\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
\newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}

%\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
%\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{Gen}}\xspace}
\newcommand{\prv}{\ensuremath{\mathrm{P}}\xspace}
\newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\inp}{\ensuremath{x}\xspace}
\newcommand{\wit}{\ensuremath{\omega}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{V}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{P}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\prf}{\ensuremath{\pi}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{ {\mathcal A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}

\renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathcal R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\begin{abstract}
We investigate the minimal number of group elements and prover running time in a zk-SNARK when using only a symmetric ``linear'' knowledge assumption, like the $d$-Power Knowledge of Exponent assumption, rather than a ``quadratic'' one as implicitly happens in the most efficient known construction by Groth \cite{Groth16}. The proofs of 
\cite{Groth16} contain only 3 group elements.
We present 4 element proofs for quadratic arithmetic programs/rank 1 constraint systems under the $d$-PKE with very similar prover running time to \cite{Groth16}. Central to our construction is a simple lemma for ``batching'' knowledge checks, which allows us to save one proof element.
\end{abstract}

\section{Introduction}
The most efficient known proving systems with succinct proofs rely on very strong cyrptographic assumptions, sometimes called non-falsifiable \cite{Naor03}. This was shown to be necessary in a sense \cite{GW11}. More specifically, the type of non-falsifiable assumptions used are refered to as \emph{knowledge assumptions}.
Rather than being assumptions of what is hard for an adversary to do, they are of the form: \emph{if} the adversary succeeded in a certain task, \emph{he must have done it in a certain way}. More concretely, the assumptions are typically about answers to certain challenges being linear combinations of CRS elements, which translates to an extractor being able to output the coefficients of this combination.

The aim of this work is to try to minimize the type of knowledge assumption made, while preserving efficiency as much as possible.
\subsection{On linear and quadratic knowledge assumptions}
We present a framework for instantiating different knowledge assumptions to motivate our result.
The definitions in this section are presented at a semi-formal level, as besides motivating the result, they are not needed for formally deriving or stating it.

In the following, for $a\in \F$, \enc{a} denotes a group element $a\cdot g\in \G$
where \F is a finite field of prime order  and \G an additive group
also equal order. (See Section \ref{subsec:terminology} for more details on notation and terminology.)


%Let $f:\F^\ell \to \F^t$ be a mapping where $f_i(\X)$ is always a rational function with numerator and denumerator both of degree
%at most $D=\poly$.
Let us recall the $d$-Power Knowledge of Exponent assumption ($d$-PKE) central to many SNARK constructions, e.g. \cite{GGPR,PHGR}:
The adversay \adv recieves a set of encoded elements $\sett{\enc{\tau^i},\enc{\alpha \tau^i}}{i\in [0..d]}$,
together with other elements independent of $\alpha$.
\adv is then given the challenge of producing another pair of `ratio' $\alpha$; i.e. a pair of the form $(\enc{c},\enc{c'})= (\enc{c},\alpha\cdot \enc{c})$.
Note that a natural way to answer the challenge is by taking \enc{c} to be some linear combination of the elements \set{\enc{\tau^i}} and by taking \enc{c'} to be the corresponding combination
of the elements \set{\enc{\alpha\tau^i}}.
That is, taking
\[\enc{c}\defeq \sum_{i=0}^d a_i \cdot \enc{\tau^i},\enc{c'}\defeq \sum_{i=0}^d a_i \cdot \enc{\alpha\tau^i},\]
for some $\a=(a_0,\ldots,a_d)\in \F^{d+1}$.
The $d$-PKE states that this is the \emph{only way} for \adv to succeed with non-negligible probability.
``Only way'' is then formalized by saying that whenever \adv succeeds in the challenge, another algorithm \ext, a.k.a. the extractor, will succeed in outputting the corresponding \a.

Let us abstract what is going on in the $d$-PKE, so that we may generalize it. 
We had a \emph{challenge equation}
\[Y_2=\alpha\cdot Y_1.\]
\adv was challenged to find group elements \enc{c},\enc{c'} such that encoded elements $c,c'$ satisfy the equation.
\adv is given a \emph{challenge set} of elements in order to aid him in completing the challenge.
In the $d$-PKE the challenge set is always of the form $\sett{\enc{\tau^i},\enc{\alpha \tau^i}}{i\in [0..d]}$ together with elements
that are independent of $\alpha$.

With this terminology, it is not hard to see the $d$-PKE is equivalent to the following slightly more abstract phrasing:
The only way to satisfy the challenge equation is by taking $\enc{c},\enc{c'}$ to be linear combinations of the challenge elements such that the equation holds as a polynomial identity in $\tau,\alpha$ (and possibly other variables appearing in the auxiliary information independent of $\alpha$).

Now, given this terminology and phrasing of the assumption, it is immediate to see how it generalizes.
Instead of looking at the equation $Y_2=\alpha \cdot Y_1$, we could look at any equation.
%whose coefficients are expressions in \X.

For example, a multi-variate linear equation
$Y_t= \alpha_1\cdot Y_1 +\ldots + \alpha_{t-1}\cdot Y_{t-1}$.
Lemma \ref{lem:batchPKE} will roughly show that this equation does not lead to a stronger assumption than the two variable original version.
% 
% We could look at a challenge set where the elements multiplied by $\alpha$ are not necessarily powers of $\tau$, but a more general set. The derived assumption is exactly what our construction will use and is Definition \ref{dfn:linearkoeassumption}.

Naturally, we could also look at higher degree challenge equations.
When our proofs are pairing-based, as the equations are typically derived from verifier checks, there is no point in looking at degree larger than two.
Assuming \adv is a generic group adversary as in the security proof of Groth \cite{Groth16} implies\footnote{This is strictly true when the auxiliary data is ``low-degree'' in the sense described in Definition \ref{dfn:koeassumption} and Remark \ref{rem:benign}} making the assumption for any degree $d$ equation and challenge set when $d=\poly$.
In particular, instead of using the generic group model, the security proof of \cite{Groth16} can be done by making such an assumption for some \emph{quadratic} equation.

Arguably, assumptions involving quadratic equations are stronger than assumptions regarding linear equations, which is why it is of value to maximize SNARK efficiency while restricting oneself to linear assumptions like the $d$-PKE - this being the purpose of our work.

\paragraph{Symmetric vs asymmetric assumptions}
Groth and Maller \cite{GM17} cleverly notice that when using an asymmetric pairing
even the trivial equation $Y_2=Y_1$ can lead to a plausible assumption when requiring $c$ and $c'$ to be encoded in the distinct source groups;
and that using square arithmetic programs inspired by Danezis et. al \cite{DFGK14}, one can get a 3 element proof as in \cite{Groth16} under only the linear assumption corresponding to this equation (with a ``bonus'' of obtaining simulation extractability which was the focus of that work). However, the use of SAPs rather than QAPs increases field and group operations significantly when starting with an arithmetic circuit; and arguably a symmetric linear assumption is better than the non-symmetric one used by \cite{GM17} - which can roughly be seen as assuming there is no efficiently computable isomorphism between the two pairing source groups, even when requiring correct computation on only a polynomially small fraction of inputs.


\subsection{Relation to previous work}
As alluded to above, the most relevant works for comparison are \cite{Groth16,GM17}.
We also mention that our security proof is very much inspired by that of \cite{GM17}.
We summarize the tradoffs between the three works.
Suppose we start with an arithmetic circuit with $n$ multiplication gates, $m$ wires.
We think of $\ell<m$ of the wires as public (usually these will all be input and output wires of the circuit), and are interested in a zk-SNARK showing
that given a value \inp of the public wires, the prover knows an assignment to the other $m-\ell$ wires consistent with the circuit computation.
Below $E_1 (E_2)$ denotes exponentations in $\G_1 (\G_2)$, $P$ means pairings.

Pairing based SNARKs are almost always instantiated using asymmetric pairings, where operations in the second source group $\G_2$ are considerably more expensive than in the first.

The main point here is that we preserve the amount of $\G_2$ prover operations from \cite{Groth16}, rather than doubling it as in \cite{GM17}, while adding roughly only $n$ $\G_1$ operations.

 \paragraph{\cite{Groth16}:} \textit{\textbf{Size:}} 2 $\G_1$, 1 $\G_2$.  \textit{\textbf{Prover operations:}} 
 $m+3n-\ell+3$ $E_1$, $n+1$ $E_2$. \textit{\textbf{Verifier operations:}} $\ell$ $E_1$, 3 $P$. \textit{\textbf{Knowledge assumption:}} Quadratic symmetric.
 \paragraph{\cite{GM17}:} \textbf{\textit{Size:}} 2 $\G_1$, 1 $\G_2$.  \textbf{\textit{Prover operations:}} 
 $m+4n-\ell$ $E_1$, $2n$ $E_2$. \textbf{\textit{Verifier computation:}} $\ell$ $E_1$, 5 $P$, \textbf{\textit{Knowledge assumption:}} Linear asymmetric.
 \paragraph{This work:} \textbf{\textit{Size:}} 3 $\G_1$, 1 $\G_2$.  \textbf{\textit {Prover operations:}} 
 $m+2n+\mathrm{min}(2n,m+2)-\ell+2$ $E_1$, $n$ $E_2$. \textbf{\textit{Verifier computation:}} $\ell$ $E_1$, 5 $P$. \textit{\textbf{Knowledge assumption:}} Linear symmetric.
 

% \begin{table}[]
% \begin{tabular}{l|l|l|m{4cm}}
%                      & Groth  & Groth-Maller & This work \\ \hline
% Proof Size           &  2 $\G_1$, 1 $\G_2$ &      2 $\G_1$, 1 $\G_2$         &  3 $\G_1$, 1 $\G_2$ \\        \hline
% Prover Computation   &  $m+3n-\ell+3\;E_1\;n+1$ $E_2$      &      $m+4n-\ell\;E_1$, $2n\;E_2$        &  $m+2n+\mathrm{min}(2n,m+2)$\newline $-\ell+2\;E_1$, $n$ $E_2$    \\     \hline
% Verifier Computation &        &              &  \\  \hline       
% Knowledge Assumption &        &              &   \\  \hline 
% \end{tabular}
% \end{table}



\subsection{Terminology and conventions}\label{subsec:terminology}
We assume we are given a finite field \F and group \G both of the same prime order $r$,
together with a generator $g\in\Gstar$.
For $x\in\F$ we denote $\enc{x}\defeq x\cdot g$ and refer to \enc{x} as an \emph{encoding of $x$}.
For a set or vector $T$ of elements of \F, we refer by \enc{T} to the corresponding set or vector of element encodings;
e.g. $\enc{(a_1,\ldots,a_t)}\defeq (\enc{a_1},\ldots,\enc{a_t})$. 

We assume our common reference strings are always of the following form.
We have a fixed map $f:\F^{\ell} \to \F^t$ where for each $i\in [\ell]$ $f_i(X)$ is a rational function of total degree at most $d$ in both numerator and denumerator,
and the common reference string is of the form $\enc{f(\x)}$ for uniform $\x\in\F^\ell$

We assume all objects and algorithms are dependent on an implicit integer parameter $\lambda$.
For example, when we refer to a field \F, we implicitly mean an infinite sequence of fields $\F(\lambda)$ indexed by $\lambda$.
When we refer to a party \adv as \emph{efficient} we mean a circuit of size \poly.
When we say a function is \emph{efficiently computable} we mean it is computable by a uniform algorithm of running time \poly.

Moreover, we assume existence of an efficient group generator \groupgen, that given $\lambda$ outputs 
representations of groups $\G,\Gt$ and a finite field \F all of prime order $r\geq 2^{\lambda}$,
and a uniformly chosen generator $g\in \G$.
We also assume the existence of an efficiently computable non-degenerate bi-linear pairing $e:\G\times\G \to \Gt$.
Whenever stating a theorem or assumption, we assume the involved parties have access to the output of \groupgen. So, when stating a cryptographic assumption, the assumption implicitly depends on the group generator used.


\section{Cryptographic assumptions}

%Previous proving systems \cite{GGPR, PHGR} relied on the \emph{d-power knowledge of exponent assumption:}
We formally define the $d$-PKE that was described in the previous section.
\begin{dfn}[$d$-Power Knowledge of Exponent Assumption ($d$-PKE)]\label{dfn:koeassumption}
For any efficient \adv there exists an efficient \ext such that the following holds.
Fix a constant $t$ and $M=\poly$, and an efficiently computable degree $d$ rational map $S:\F^{t+1}\to\F^M$.
 Consider the following experiment.

 $\tau,\alpha\in \F,\x\in\F^t$ are chosen uniformly. We denote $V\defeq \koevec{\tau}{d}$
 Then \adv is given as input $(V,S(\tau,\x))$
 and outputs a pair $(\enc{c},\enc{c'})$ of $\G$ elements, which he ``hopes'' is of the form $(\enc{c},\enc{\alpha c})$.
   \ext, given the same input, outputs a polynomial $A\in \F[X]$ of degree at most $d$ that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $c'=\alpha\cdot c$. But,
  \item \ext ``failed'', i.e., $c \neq A(\tau)$.
   \end{enumerate}
is \negl.
 %The same holds when \G11 is replaced by \G21 and $g_1$ is replaced by $g_2$.
\end{dfn}
\begin{remark}\label{rem:benign}
Typically the PKE assumption is defined with arbitrary auxiliary information rather than a rational map.
Our definition is weaker and corresponds to imposing the auxiliary information to be the encoded output of a low degree rational map on a uniform input,
and suffices for the security proofs of \cite{GGPR,PHGR}.
This increases the chance our auxiliary information is ``benign'' and our assumption does not contradict indistinguishability obfuscation \cite{BCPR13}.
\end{remark}

We show that the $d$-PKE can be used to ``batch'' knowledge checks.

\begin{lemma}\label{lem:batchPKE}
Assuming the $d$-PKE the following holds. Fix $k=\poly$,
a constant $t$ and an efficiently computable degree $d$ rational map $S:\F^{t+1}\to\F^M$.
Fix any $i\in [k]$.
For any efficient \adv there exists an efficient \ext such that the following holds.
Consider the following experiment.
 $\alpha_1,\ldots\alpha_k,\tau\in \F$ and $\x\in\F^t$ are chosen uniformly.
 \adv is given as input $\enc{S(\tau,\x)}$ and $\sett{\enc{\alpha_j\cdot \tau^\ell} }{j\in [k], \ell \in [0..d]}$
 and outputs a sequence of elements  $(\enc{a_1},\ldots, \enc{a_k},\enc{b})$ in $\Gstar$.
   \ext, given the same input as \adv together with the randomness of \adv and $\sett{\alpha_j}{j\in [k]\setminus\set{i}}$, outputs  
 $A(X) \in \F[X]$ of degree at most $d$ such that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $b=\sum_{j=1}^k\alpha_j\cdot a_j$. But,
  \item \ext ``failed'', i.e., $a_i \neq \enc{A(\tau)}$.
   \end{enumerate}
is \neg.
\end{lemma}
\begin{proof}
 Fix $k,t,S,\adv$ and $i\in [k]$ as in the lemma. Assuming the $d$-PKE we aim to construct \ext satisfying the lemma statement. Consider the following efficient $\advv$, that on input $\enc{S(\tau,\x)}\cup \sett{\enc{\alpha_i \tau^\ell}}{\ell\in [0..d]}$ samples random \sett{\alpha_\ell\in \Fstar}{\ell\in [k]\setminus\set{i}},  computes $\sett{\enc{\alpha_j \tau^\ell}}{j \in [k]\setminus\set{i}, \ell\in [0..d]}$ and invokes \adv with
 uniformly chosen randomness \randadv on $\enc{S(\tau,\x)}\cup\sett{\enc{\alpha_j\cdot \tau^\ell} }{j\in [k], \ell \in [0..d]}$.
 When \adv returns $(\enc{a_1},\ldots,\enc{a_k},\enc{b}
 )$, \advv returns $(\enc{a_i},\enc{b'})$ where
 \[\enc{b'} = \enc{b}-\sum_{j\in [k]\setminus\set{i}} \alpha_j\cdot \enc{a_j}.\]
 Note that \adv succeeds exactly when \advv succeeds in the sense that
 %given any value of $\enc{S(\tau,\x)},\set{\alpha_j},\randadv$,
 \[\sum_{j\in [k]} \alpha_j\cdot a_j  = b \Leftrightarrow \alpha_i\cdot a_i = b'.\]
 Let \extprime be the extractor guaranteed to exist for $\advv,S$ from the $d$-PKE.
 Note that the input for \extprime is $\enc{S(\tau,\x)}\cup \sett{\enc{\alpha_i \tau^\ell}}{\ell\in [0..d]}$ together with the inner randomness of \advv which is 
 $\randadv,\sett{\alpha_\ell}{\ell\in [k]\setminus\set{i}}$.
 Given this input the probability that \advv succeeds in outputting a pair $(\enc{a_i},\enc{b'})$ with $b'=
 \alpha_i\cdot a_i$, and \ext doesn't output $A$ of degree at most $d$ with $A(\tau) = a_i$ is \negl.
 Now define \ext to be the (identical) extractor that given 
 $\randadv,\enc{S(\tau,\x)}\cup \sett{\enc{\alpha_i \tau^\ell}}{\ell\in [0..d]},\sett{\alpha_\ell}{\ell\in [k] \setminus\set{i}}$,
 simply returns the output $A$ of \extprime on the same input.
\end{proof}



The following assumption generalizes the $d$-SDH and $d$-PDH used in \cite{GGPR, PHGR}, and is very similiar to computational polynomial assumption from \cite{GM17},
except that it also allows rational functions.

The $d$-PDH for example, says you should not be able to output \enc{\tau^{d+1}} after seeing encodings of smaller powers of $\tau$. The generalization here is that we assume an adversary, after seeing encoded evaluations of multi-variate rational functions, can only knowingly output an encoding of a rational function that is in the span of those it has seen.
\begin{dfn}[(t,d)-SPAN]\label{dfn:spanassump}
 Fix integers $t,d$.
Fix an efficiently computable degree $d$ rational map $S:\F^{t}\to\F^M$.
Let $V$ be the $\F$-subspace of $\F(X_1,\ldots,X_t)$
spanned by the output coordinates of $S$; i.e.
$V\defeq \span(\sett{S_i}{i\in[M]})$.
Fix any efficient \adv, and consider the following game:
 Uniform $\x \in \F^t$ is sampled and  \adv is given \enc{S(\x)}. Then the probability that \adv 
 outputs  $p,q\in \F(X)$ and $h\in \G$ such that
 \begin{enumerate}
  \item $\deg(p),\deg(q)\leq d$.
  \item $p/q \notin V$.
  \item $h= \enc{p(\tau)/q(\tau)}$
 \end{enumerate}
is \negl
\end{dfn}


\section{SNARK definitions}
We formally define zk-SNARKs.
We make a slightly non-conventional definition of knowledge soundness, where we allow the knowledge extractor access to
part of the CRS trapdoor.
%We deviate a bit in the definition of knowledge soundness, by giving the extractor access to part of the trapdoor.
\begin{dfn}\label{dfn:zkSNARK}
%Let \groupgen be a group generator for a prime field \F, and $\rel\subset \vecof{\F}$ a relation. 
An zk-SNARK \snark (zero-knowledge Succinct Non-interactive Argument of Knowledge) for a relation \rel consists of the following four possibly randomized algorithms.
\begin{enumerate}
 \item \gen outputting a pair of trapdoors $(\trapdoorext,\trapdoorsim)$ and common reference string \crs.
 \item \prv that takes as input \crs and $(\inp,\wit)\in \rel$ and outputs
 \prf.
 \item \ver that takes as input a common reference string \crs, an input \inp, and a proof \prf, and outputs a value in \set{\acc,\rej}.
 \item \simprv taking as input \inp, and trapdoor \trapdoorsim and outputting  \prf.
 (It will be convenient to think of \simprv as returning $(\inp,\prf)$.)
\end{enumerate}

The quadruple of algorithms $\snark = (\gen,\prv,\ver,\simprv)$ is a zk-SNARK for \rel if it satisfies

\begin{enumerate}
 \item \textbf{Completeness}: For any common reference string \crs output by \gen, and any $(\inp,\wit)\in \rel$, if $\prf = \prv(\crs,\inp,\wit)$; then
 $\ver(\crs,\inp,\prf) = \acc$ with probability one.
\item \textbf{Statistical Zero-Knowledge:} For any output $(\trapdoor,\crs)$ of \gen and $(\inp,\wit)\in \rel$, the distribution\footnote{For simplicity, we present our SNARK with only statistical zero-knowledge, but a slight complication of the construction can give perfect zero-knowledge.} of $\simprv(\trapdoor,\inp)$
is \negl-close to that of $\prv(\crs,\inp,\wit)$.

\item \textbf{Knowledge Soundness:}

For any efficient adversary \adv, there exists an efficient  \ext such that the following holds:
Suppose that \adv, given \crs,
outputs a pair $(\inp,\prf)$ and \ext given \advrand and \trapdoorext,
outputs \wit.
The probability, over the randomness of \adv and that of \gen while outputting $((\trapdoorext,\trapdoorsim),\crs)$,
 that 
\begin{itemize}
 \item \adv ``wins'': $\ver(\inp,\prf,\crs)=\acc$, and
 \item \ext ``loses'': $(\inp,\wit)\notin \rel$
\end{itemize}
is \negl.
 \end{enumerate}
 
 \end{dfn}
\subsection{QAPs} 
We assume familiarity with quadratic arithmetic programs \cite{GGPR}, but briefly describe the necessary definitions.
A QAP \qap of size $m$, degree $n$, with $\ell$ public inputs over \F
is defined by a set of univariate polynomials \set{\sett{A_i(X),B_i(X),C_i(X)}{i\in [0..m]}, Z(X)}
where $A_i,B_i,C_i\in \F[X]$ have degree smaller than $n$, and $Z\in \F[X]$ has degree exactly $n$.
We say $\inp=(x_1,\ldots,x_\ell)\in \F^\ell,\wit=(x_{\ell+1},\ldots,x_m) \in \F^{m-\ell}$ \emph{satisfy \qap}, if when defining $x_0=1$,
$A\defeq \sum_{i=0}^m x_i\cdot A_i, B\defeq \sum_{i=0}^m x_i \cdot B_i,$ and $C\defeq \sum_{i=0}^m x_i \cdot C_i$;
then the polynomial $P\defeq A\cdot B - C$ will be divisble by $Z$.

\subsection{Randomizing QAP witnesses}
When describing our SNARK in the next section we will assume the sequences of QAP polynomials were extended in the following way:
\[A_{m+1}=B_{m+2}=Z, A_{m+2}=B_{m+1}=C_{m+1}=C_{m+2} =0.\]
(note in particular that we allow these new polynomials to be of degree $n$ while the former are of degree smaller than $n$.)
For any values $x_{m+1},x_{m+2}\in\F$, $\inp,(\wit,x_{m+1},x_{m+2})$ satisfy the extended QAP if and only if $\inp,\wit$ satisfiy the original one.
When describing the prover algorithm in the next section we will assume the values of $x_{m+1},x_{m+2}$ in the prover's witness \wit have been chosen uniformly, and also reindex and denote by $m$ the total number of QAP polynomials after this extension.

\section{Description of our SNARK}\label{subsec:SNARK}


 Let $R$ be the relation of pairs $(\inp,\wit)$ such that $\inp,\wit$ satisfy \qap.
We proceed to describe our zk-SNARK for the relation $R$.

%We assume we are already given a description of the groups $\G,\Gt$, the pairing $e$, and a uniformly chosen generator 
%$g\in \G$, and these are all public.
\paragraph{\underline{Key Generation:}}

\paragraph{}
\begin{enumerate}
 \item Sample random $\tau,\beta_A,\beta_B,\delta\in \F$.
 \item Define, for $i\in [0..m]$, the tri-variate polynomial $K_i(\tau,\beta_A,\beta_B)\defeq \beta_B A_i(\tau) + \beta_A B_i(\tau) + C_i(\tau)$. And the rational map 
 \[\crs_1(\tau,\beta_A,\beta_B,\delta) \defeq \sett{\tau^i,\tau^i/\delta,\beta_A \tau^i,\beta_B\tau^i}{i\in[0..n]}\cup \sett{K_i(\tau)/\delta}{i\in [0..m]}
 \]
\item For $\tau,\alpha_A,\alpha_B,\in\F$, define $\crs_2(\tau,\alpha_A,\alpha_B)\defeq \sett{ \alpha_A\tau^i,\alpha_B \tau^i}{i\in [0..n]}$
\item Choose uniform $\tau,\beta_A,\beta_B,\delta,\alpha_A,\alpha_B\in \F$ and set

\[\crs \defeq \enc{\crs_1(\tau,\beta_A,\beta_B,\delta),\crs_2(\tau,\alpha_A,\alpha_B)}
\]
\[\trapdoorext= (\alpha_A,\alpha_B), \trapdoorsim= (\alpha_A,\alpha_B,\beta_A,\beta_B,\delta)\]
 \end{enumerate}

\paragraph{\underline{Prover:}\\}
The prover \per has in his hand a QAP solution $(x_0=1,x_1,\ldots,x_m)$ that coincides with the public input $x=(x_1,\ldots,x_\ell)$ and satisfies the following:
If we define $A\defeq \sum_{i=0}^m x_i\cdot A_i, B\defeq \sum_{i=0}^m x_i \cdot B_i,$ and $C\defeq \sum_{i=0}^m x_i \cdot C_i$;
then the polynomial $P\defeq A\cdot B - C$ will be divisble by the target polynomial $Z$, and \per can compute the polynomial $H$ of degree at most $n$ with $P=H\cdot Z$.
%Let $\amid\defeq A -\sum_{i=0}^n x_i\cdot A_i$; define \midb and \midc analogously.

Given the proving key, \per computes as linear combinations of the proving key elements $\enc{\pi_A},\enc{\pi_B},\enc{\pi_D},\enc{\pi_K}$  where 
\begin{enumerate}
\item $\pi_A\defeq A(\tau)$ .
\item $\pi_B\defeq B(\tau)$.
\item $\pi_D\defeq \alpha_A A(\tau) + \alpha_B B(\tau)$.
\item $\pi_K\defeq \left(\sum_{i=\ell+1}^m K_i(\tau,\beta_A,\beta_B)+ H(\tau)Z(\tau)\right)/\delta$.
\end{enumerate}
 and outputs $\prf = (\enc{\pi_A},\enc{\pi_B},\enc{\pi_D},\enc{\pi_K}).$
 

\paragraph{\underline{Verifier:}\\}
For $\inp=(x_1,\ldots,x_\ell)$, denote the ``public input component'' 
\[ \PI(x) \defeq K_0(\tau,\beta_A,\beta_B) + \sum_{i=1}^\ell x_i  K_i(\tau,\beta_A,\beta_B) .\]

%  For an element $a$ of \G1 (\G2) denote by \dl{a} the discrete log of $a$ w.r.t $g_1(g_2)$.
 The verifier, using pairings and the verification key, checks the following.
\begin{enumerate}
\item $\pi_D = \alpha_A\cdot \pi_A + \alpha_B \cdot \pi_B$.
\item $(\beta_A +\pi_A)\cdot (\beta_B + \pi_B) = \PI(x) + \pi_K\cdot \delta + \beta_A\cdot \beta_B$.
 \end{enumerate}
\paragraph{\underline{Simulator $(\inst,\inp,\trapdoorsim=(\tau,\alpha_A,\alpha_B,\beta_A,\beta_B,\delta)$):}\\}
\begin{enumerate}
 \item Choose $\pi_A,\pi_B\in\F$ uniformly.
 \item Let $\pi_D \defeq \alpha_A\pi_A + \alpha_B\pi_B$.
 \item Let $\pi_K \defeq \frac{1}{\delta}((\beta_A + \pi_A)(\beta_B + \pi_B)-\PI(x))$.
 Output $(\enc{\pi_A},\enc{\pi_B},\enc{\pi_D},\enc{\pi_K})$.
 \end{enumerate}

 In the next section we prove the following:
 \begin{thm}\label{thm:snarkSecure}
  Under the $n$-PKE and $(4,2n)$-SPAN assumptions the above scheme is a zk-SNARK for the relation $R$. 
 \end{thm}

 
 \section{Security proof}
 The completeness and zero-knowledge properties are easily verifiable from the construction.
 We thus focus on knowledge soundness.
 \paragraph{Description of extractor}
 Fix an efficient \adv. We need to describe the corresponding extractor \ext.
Suppose that \adv has outputted $(\inp,\prf)$ such that
$\ver(\crs,\inp,\prf)=\acc$.
Let $\prf=(\enc{\pi_A},\enc{\pi_B},\enc{\pi_D},\enc{\pi_K})$.
 
 In particular, we have
 \[\alpha_A \cdot \pi_A + \alpha_B \cdot \pi_B  = \pi_D.\]
 
 This implies by Lemma \ref{lem:batchPKE} that given $\trapdoorext =\alpha_B$
 and \advrand, \ext can extract e.w.p. \negl a polynomial $A\in\F[X]$ of degree at most $n$ such that
 \[\pi_A =A(\tau).\]
 
 \ext uses linear algebra to determine if the polynomial $\mida(X) \defeq A(X)-\sum_{i=0}^\ell x_i A_i(X)$ is in the span of the QAP polynomials \sett{A_i}{i\in[\ell+1..m]}.
 If not, \ext aborts. Otherwise, let $x_{\ell+1},\ldots,x_m \in \F$ be
 such that $\mida(X) = \sum_{i=\ell+1}^m x_i A_i(X)$, and let $\wit\defeq (x_{\ell+1},\ldots,x_m)$.
 \ext checks if $(\inp,\wit)\in R$ and if so outputs \wit as a witness for \inp.
 
 \paragraph{Analyzing \ext's failure probability}
 
 Let $\eta$ be the probability that \adv outputs a verifying $(\inp,\prf)$ with but 
 \ext doesn't output a valid witness \wit for \inp.
 To prove knowledge soundness we must show that $\eta=\negl.$
 We will construct an efficient \advv
 that solves $(4,2n)$-SPAN with probability $\eta-\negl$ thus implying $\eta=\negl$ under the $(4,2n)$-SPAN assumption.
 
 The challenge \advv will receive will be $T_1\defeq \enc{\crs_1(\tau,\beta_A,\beta_B,\delta)}$
 for uniform $\tau,\beta_A,\beta_B,\delta\in\F$.
 
 Recall that
 \[\crs_1(\tau,\beta_A,\beta_B,\delta)= \sett{\tau^i,\tau^i/\delta,\beta_A \tau^i,\beta_B\tau^i}{i\in[0..n]}\cup \sett{K_i(\tau,\beta_A,\beta_B)/\delta}{i\in [0..m]}\]
 
 \advv samples uniform $\alpha_A,\alpha_B\in\F$ and computes $T_2\defeq \enc{\crs_2(\tau,\alpha_A,\alpha_B)}$.
 Define $\crs \defeq (T_1,T_2)$.
 \advv runs $\adv(\randadv,\crs)$ to get output $(\inp,\prf)$
 and checks whether $\ver(\crs,\inp,\prf)=\acc$.
 If the check fails \advv aborts.
 Otherwise, denote $\prf = (\enc{\pi_A},\enc{\pi_B},\enc{\pi_D},\enc{\pi_K})$.
 We again have
 \[\alpha_A\cdot  \pi_A + \alpha_B \cdot \pi_B  = \pi_D\]
 
 This implies by Lemma \ref{lem:batchPKE} that given $\alpha_A,\alpha_B$
 and \advrand, \advv can extract e.w.p. \negl polynomials $A,B\in\F[X]$ of degree at most $n$ such that
 \[\pi_A = A(\tau), \pi_B =B(\tau).\]

 If one of the extractions failed, \advv aborts.
 
 %From this point on, we slightly abuse notation and use $\tau,\beta_A,\beta_B,\delta$ to denote formal variables rather than values in \F.
 \advv now computes the $4$-variate rational function
 \[C(X,X_A,X_B,X_\delta)\defeq (A(X)B(X)+ X_A B(X) + X_B A(X) - \PI(X,X_A,X_B))/X_{\delta},
 \]
where $\PI(X,X_A,X_B)\defeq \sum_{i=0}^\ell x_i\cdot K_i(X,X_A,X_B)$.
Rearranging the second verification equation we see that we have
\[\pi_K = (\pi_A\pi_B +\beta_A\pi_B + \beta_B\pi_A -\PI(X))/\delta = C(\tau,\beta_A,\beta_B,\delta).\]

Denote $U \defeq \span(\crs_1(X,X_A,X_B,X_\delta))\subseteq \F(X,X_A,X_B,X_\delta)$.
If $C\notin U$, \advv outputs $(C,\enc{\pi_K})$ as a response to the $(4,2n)$-SPAN challenge.

We show that when \prf is a valid proof but $C\in U$, then \ext outputs a valid witness:

$C\in U$ implies there are polynomials $f,f_A,f_B,H\in \F[X]$ of degree at most $n$, together with coefficients $x_{\ell+1},\ldots,x_m \in \F$, such that
\[(A(X)B(X)+ X_A B(X) + X_B A(X) - \PI(X,X_A,X_B))/X_{\delta}\]
\[= f(X)+ f_A(X)+f_B(X)+H(X)Z(X)/X_{\delta}
+\left(\sum_{i=\ell+1}^m x_i\cdot  K_i(X,X_A,X_B)\right)/X_\delta.
\]

We multiply by $X_\delta$ and add $\PI(X,X_A,X_B)$ to get 
\[A(X)B(X)+ X_A B(X) + X_B A(X)\]
\[= (f(X)+ f_A(X)+f_B(X))X_\delta+H(X)Z(X)
+\sum_{i=0}^m  x_i\cdot  K_i(X,X_A,X_B).
\]

Let us think of the above as a polynomial indentity in the variables $X_A,X_B,X_\delta$ with coefficients in $\F[X]$.
Since the constant coefficient, that of $X_A$ and that of $X_B$ must be identical on both sides, we have
\begin{enumerate}
 \item $A(X)B(X)= \sum_{i=0}^m x_i\cdot C_i(X) + H(X)Z(X)$.
 \item $B(X) = \sum_{i=0}^m x_i\cdot B_i(X)$.
 \item $A(X) = \sum_{i=0}^m x_i \cdot A_i(X)$
\end{enumerate}
This exactly means that $\wit\defeq (x_{\ell+1},\ldots,x_m)$ 
is a valid witness for \inp.
And \wit exactly corresponds to the output of \ext.
 
 
 \section*{Acknowledgements}
We thank Jens Groth and Mary Maller for helpful discussions on the subject of this paper.
 \bibliographystyle{alpha}
\bibliography{References}

\end{document}
 
