\def\notes{1}
\documentclass[11pt]{article}
%\usepackage[T1]{fontenc}
%\usepackage[letterpaper]{geometry}
%\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
%\usepackage{verbatim}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
%\usepackage{setspace}
\usepackage{xspace}%,enumitem}
%\usepackage{times}
\usepackage{fullpage}
%\usepackage{hyperref}
%\doublespacing
\usepackage{color}
\usepackage{numdef}
\usepackage{enumitem}
\usepackage{amsopn}
%\usepackage{hyperref} 
\usepackage{mathrsfs}

\providecommand{\sqbinom}{\genfrac{\lbrack}{\rbrack}{0pt}{}}
\DeclareMathOperator{\spn}{span}

\newif\ifdraft
%\drafttrue
\draftfalse
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
%\numberwithin{equation}{section} %% Comment out for sequentially-numbered
\numberwithin{figure}{section} %% Comment out for sequentially-numbered
\newtheorem{thm}{Theorem}[section]
\newtheorem{conjecture}[thm]{Conjecture}
\newtheorem{definition}[thm]{Definition}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{remark}[thm]{Remark}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{claim}[thm]{Claim}
\newtheorem{fact}[thm]{Fact}
\newtheorem{openprob}[thm]{Open Problem}
\newtheorem{remk}[thm]{Remark}
\newtheorem{example}[thm]{Example}
\newtheorem{apdxlemma}{Lemma}
\newcommand{\question}[1]{{\sf [#1]\marginpar{?}} }
%\usepackage{babel}
\usepackage{tikz}

\makeatletter
\newcommand*{\circled}{\@ifstar\circledstar\circlednostar}
\makeatother

\newcommand*\circledstar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      fill,
      circle,
      minimum size=1.35em,
      text=white,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}
\newcommand*\circlednostar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      draw,
      circle,
      minimum size=1.35em,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}

\providecommand{\bd}[1]{\circled{#1}}


%Eli's macros
\newcommand{\E}{{\mathbb{E}}}
%\newcommand{\N}{{\mathbb{N}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\calF}{{\cal{F}}}
%\newcommand{\inp}[1]{\langle{#1}\rangle}
\newcommand{\disp}[1]{D_{#1}}
%\newcommand{\spn}[1]{{\rm{span}}\left(#1\right)}
%\newcommand{\supp}{{\rm{supp}}}
\newcommand{\agree}{{\sf{agree}}}
\newcommand{\RS}{{\sf{RS}}}
\newcommand{\aRS}{{\sf{aRS}}}
\newcommand{\rrs}{R_{\aRS}}
\newcommand{\VRS}{V_\RS}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\renewcommand{\a}{\ensuremath{\mathbf{a}}\xspace}

\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}
\newcommand{\Y}{\ensuremath{\mathbf{Y}}\xspace}
\newcommand{\y}{\ensuremath{\mathbf{y}}\xspace}

\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\angles}[1]{\langle{#1}\rangle}
\renewcommand{\span}{\ensuremath{\mathsf{span}}\xspace}
\newcommand{\condset}[2]{\set{#1 \mid #2 }}
\newcommand{\zo}{\set{0,1}}
\newcommand{\zon}{{\zo^n}}
\newcommand{\zom}{{\zo^m}}
\newcommand{\zok}{{\zo^}}
\newcommand{\eps}{\epsilon}
\newcommand{\e}{\eps}
%\newcommand{\d}{\delta}
\newcommand{\poly}{\ensuremath{\mathrm{poly}(\lambda)}\xspace}
\newcommand{\itone}{{\it{(i)}}\xspace}
\newcommand{\ittwo}{{\it{(ii)}}\xspace}
\newcommand{\itthree}{{\it{(iii)}}\xspace}
\newcommand{\itfour}{{\it{(iv)}}\xspace}
\newcommand{\cc}{{\rm{CC}}}
\newcommand{\rnk}{{\rm{rank}}}
\newcommand{\T}{T}
\newcommand{\I}{{\mathbb{I}}}
\ifdraft
\newcommand{\ariel}[1]{{\color{blue}{\textit{#1 --- ariel gabizon}}}}
\else
\newcommand{\ariel}[1]{}
\fi
\providecommand{\improvement}[1]{{\color{red} \textbf{#1}}}
\title{%
On the size of pairing-based proofs under linear knowledge assumptions}
\date{\today}
\author{Ariel Gabizon\thanks{Part of this work was done while being supported by the Zcash Company.}}
\date{}
\begin{document}
\maketitle
 \mathchardef\mhyphen="2D

%\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}

%\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{A}\xspace}
\newcommand{\advprime}{\ensuremath{A'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\abase}{\ensuremath{A_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\bbase}{\ensuremath{B_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\cbase}{\ensuremath{C_{\mathrm{\mathbf{0}}}}\xspace}

\newcommand{\amid}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\bmid}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\cmid}{\ensuremath{C_{\mathrm{mid}}}\xspace}

\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
\newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
\newcommand{\snark}{\ensuremath{\mathscr S}\xspace}

\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\A}{\ensuremath{\vec{A}}\xspace}
\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
\newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}

%\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
%\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{Gen}}\xspace}
\newcommand{\prv}{\ensuremath{\mathrm{P}}\xspace}
\newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\inp}{\ensuremath{x}\xspace}
\newcommand{\wit}{\ensuremath{\omega}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{V}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{P}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\prf}{\ensuremath{\pi}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{A^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
\renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\log r)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathcal R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI_A}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\begin{abstract}
We investigate the minimal number of group elements in a SNARK proof when using only a ``linear'' knowledge assumption rather than a ``quadratic'' one as implicitly happens in Groth \cite{Groth16}.
We present a simple lemma to ``batch'' knowledge checks that allows us to batch 4 elements of the Pinocchio proof system into one. As a result we get proofs with 5 group elements under very similar assumptions to the 8-element proofs of \cite{PHGR}.
\end{abstract}

\section{Introduction}
The most efficient known proving systems with succinct proofs rely on very strong cyrptographic assumptions, sometimes called non-falsifiable \cite{Naor03}. This was shown to be necessary in a sense \cite{GW11}. More specifically, the type of non-falsifiable assumptions used are refered to as \emph{knowledge assumptions}.
Rather than being assumptions of what is hard for an adversary to do, they are of the form: \emph{if} the adversary succeeded in a certain task, \emph{he must have done it in a certain way}. More concretely, the assumptions are typically about answers to certain challenges being linear combinations of CRS elements, which translates to an extractor being able to output the coefficients of this combination.
\paragraph{Terminology}
We assume we are given a finite field \F and group \G both of the same prime order $r$,
together with a generator $g\in\Gstar$.
For $x\in\F$ we denote $\enc{x}\defeq x\cdot g$ and refer to \enc{x} as an \emph{encoding of $x$}.
For a set or vector $T$ of elements of \F, we refer by \enc{T} to the corresponding set or vector of element encodings;
e.g. $\enc{(a_1,\ldots,a_t)}\defeq (\enc{a_1},\ldots,\enc{a_t})$. 

We assume our common reference strings are always of the following form.
We have a fixed map $f:\F^{\ell} \to \F^t$ where for each $i\in [\ell]$ $f_i(X)$ is a rational function of total degree at most $d$ in both numerator and denumerator,
and the common reference string is of the form $\enc{f(\x)}$ for uniform $\x\in\F^\ell$

\subsection{On linear and quadratic knowledge assumptions}
We present a framework for instantiating different knowledge assumptions to motivate our result.
The definitions in this section are presented at a semi-formal level, as besides motivating the result, they are not needed for formally deriving or stating them.

%Let $f:\F^\ell \to \F^t$ be a mapping where $f_i(\X)$ is always a rational function with numerator and denumerator both of degree
%at most $D=\poly$.
First, let us recall the $d$-Power Knowledge of Exponent assumption ($d$-PKE) central to the constructions of \cite{GGPR,PHGR}:
The adversay \adv recieves a set of encoded elements $\sett{\enc{\tau^i},\enc{\alpha \tau^i}}{i\in [0..d]}$,
together with other elements independent of $\alpha$.
\adv is then given the challenge of producing another pair of `ratio' $\alpha$; i.e. a pair of the form $(\enc{c},\enc{c'})= (\enc{c},\alpha\cdot \enc{c})$.
Note that a natural way to answer the challenge is by taking \enc{c} to be some linear combination of the elements \set{\enc{\tau^i}} and by taking \enc{c'} to be the corresponding combination
of the elements \set{\enc{\alpha\tau^i}}.
That is, taking
\[c\defeq \sum_{i=0}^d a_i \cdot \enc{\tau^i},c'\defeq \sum_{i=0}^d a_i \cdot \enc{\alpha\tau^i},\]
for some $\a=(a_0,\ldots,a_d)\in \F^{d+1}$.
The $d$-PKE states that this is the \emph{only way} for \adv to succeed with non-negligible probability.
``Only way'' is then formalized by saying that whenever \adv succeeds in the challenge, another algorithm \ext, a.k.a. the extractor, will succeed in outputting the coefficients of the corresponding linear combination.

Let us abstract what is going on in the $d$-PKE, so that we may generalize it. 
We had a \emph{challenge equation}
\[Y_2=\alpha\cdot Y_1.\]
\adv was challenged to find group elements \enc{c_1},\enc{c_2} such that encoded elements $c_1,c_2$ satisfy the equation.


\adv is given a \emph{challenge set} of elements in order to aid him in completing the challenge.
In the $d$-PKE the challenge set is always of the form $\sett{\enc{\tau^i},\enc{\alpha \tau^i}}{i\in [0..d]}$ together with elements
that are independent of $\alpha$.

With this terminology, it is not hard to see the $d$-PKE is equivalent to the following slightly more abstract phrasing:
The only way to satisfy the challenge equation is by taking $\enc{c_1},\enc{c_2}$ to be linear combinations of the challenge elements such that the equation holds as a polynomial identity in \X.

Now, given this terminology and phrasing of the assumption, it is immediate to see how it generalizes.
Instead of looking at the equation $Y_2=\alpha \cdot Y_1$, we could look at any equation whose coefficients are expressions in \X.

For example, if $\X=(\alpha_1,\ldots,\alpha_{t-1})\cup \X'$, we could look at a more general linear equation
$Y_t= \alpha_1\cdot Y_1 +\ldots + \alpha_{t-1}\cdot Y_{t-1}$.
Lemma \ref{lem:batchLKE} will roughly show that this equation does not lead to a stronger assumption than the two variable original version.

We could look at a challenge set where the elements multiplied by $\alpha$ are not necessarily powers of $\tau$, but a more general set. The derived assumption is exactly what our construction will use and is Definition \ref{dfn:linearkoeassumption}.

Naturally, we could also look at higher degree challenge equations. When are proofs are pairing-based, as the equations are typically derived from verifier checks, there is no point in looking at degree larger than two.

\cite{Groth16} implicitly uses an assumption with a quadratic equation.

Assuming \adv is a generic group adversary corresponds to making the assumption for any degree $d$ equation and challenge set when $d=\poly$.
The security proof of \cite{Groth16} in the generic group model, can be viewed in this framework as making such an assumption for some \emph{quadratic} equation.

Arguably, assumptions involving quadratic equations are stronger than assumptions regarding linear equations, which is why it is of value to maximize SNARK efficiency when restricting oneself to linear assumptions - and this is precisely the theme of this work
% 
% 
% In this terminology, what \cite{Groth16}
% 
% 
% A uniform $(\x,\in\F^\ell$ is chosen and the adversary recieves \set{\enc{a_i\defeq f_i(\x)}}.
% Now the adversary is given some equation where the values \set{a_i} can be used in the coefficients of the equation.
% 
% 
% an adversary is given a challenge to find \y to variables \Y is 
% 
% 
% 
% Roughly speaking, \cite{GGPR,PHGR} relied on what we refer to here as a \emph{linear} knowledge assumptions:
% Suppose I give you a set of group elements; assume for simplicity these group elements are evaluations of linearly independent
% polynomials $f_i(X)$ of degree at most $d$ on a uniformly chosen point $\x\in(\Fstar)^{\ell}$.
% Then for some subset $T$ of these elements, I also give you the elements multiplied by $\alpha$
% for a uniform and independent $\alpha\in\Fstar$.
% 
% Then I give you a challenge: Produce some pair of group elements of `ratio $\alpha$', i.e. a pair of the form $(\enc{c},\enc{d})= (\enc{c},\alpha\cdot \enc{c})$.
% Note that if I construct $\enc{c}$ as a linear combination $\enc{c}=\sum_{x\in T} a_x\cdot x$ for coefficients $a_x\in\F$,
% I would be able to construct the element $\alpha\cdot \enc{c} =\sum_{x\in T} a_x\cdot \alpha x$, as I possess the elements $\alpha\cdot x$ for $x\in T$.
% A ``linear'' knowledge assumption would assert that this is the only way one could construct a pair of ratio $\alpha$.
% It is linear in the sense that the equation I am challenged to satisfy, when thinking of $\alpha$ as a coefficient, is linear
% in the encoded elements $c,d$; specifically the equation is $Y=\alpha\cdot X$.
% One way to phrase this assumption is:
%  that the only way of satisfying the equation $Y=\alpha\cdot X$, is by
% \begin{enumerate}
%  \item Having the assignment to $X,Y$ be linear combinations of the received elements.
%  \item These linear combinations being such that the equation is a polynomial identity in $\x,\alpha$.
% \end{enumerate}
% 
% This 
% 
% 
% To go beyond the efficiency of \cite{PHGR}, Groth \cite{Groth16} assumed his adversary is a \emph{generic group adversary};
% rather than using a cryptographic assumption. In our terminology above assuming the generic group model, corresponds to assuming that also when the challenge equation is not linear the only way an adversary can satisfy it with non-negligible probability is as above - assigning the variables using linear combinations of the CRS, and acheiving a polynomial identity in the trapdoor elements.
% 
% In partciular, for \cite{Groth16} we could prove security by, instead of assuming the generic group model, assuming a ``quadratic knowledge assumption'' something like.
% The only way to supply \enc{c},\enc{d},\enc{e} satisfying
% \[c\cdot d = \delta e + \gamma\]
% for some $\delta,\gamma$ is like above.
% 
% 
% 
% It is possible, instead of using the generic group model, to prove the security of \cite{Groth16} from a concrete assumption. The assumption we would get we could aptly call a \emph{quadratic       }
% 
% 
% The most efficient known proving system, requiring only three group element proofs, was designed by Groth \cite{Groth16}. Its security is proven in the ``Generic Group Model'' in which all used non-falsifiable assumptions hold. The model implies, at least when the CRS elements are of low degree, that all the malicious prover can do is take a non-adaptive linear combination of the key elements.

\section{Cryptographic assumptions}

Previous proving systems \cite{GGPR, PHGR} relied on the \emph{d-power knowledge of exponent assumption:}

\begin{dfn}[$d$-Power Knowledge of Exponent Assumption ($d$-PKE)]\label{dfn:koeassumption}
For any efficient \adv there exists an efficient \ext such that the following holds.
Fix an efficient  randomized circuit $S$ with input domain $\G^{(d+1)}$.
 Consider the following experiment.

 $\tau,\alpha\in \F^*$ and $g\in \Gstar$ are chosen uniformly. We denote $V\defeq \koevec{\tau}{d}\cdot g$
 Then \adv is given as input $(V,S( V))$;
 and outputs a pair of the form $(c,d)$ in $\G$, which he ``hopes'' is of the form $(c,\alpha c)$.
   \ext, given the same input, outputs  
 $a_0,a_1,\ldots,a_q \in \F$ such that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $c=\alpha\cdot b$. But,
  \item \ext ``failed'', i.e., $c \neq (\sum_{i=0}^q a_i \tau^i)\cdot g_1$.
   \end{enumerate}
is \neg.
 %The same holds when \G11 is replaced by \G21 and $g_1$ is replaced by $g_2$.
\end{dfn}
\begin{remark}
Typically the PKE assumption is defined with auxiliary information rather than a randomized circuit.
Our definition is weaker since it roughly corresponds to imposing the auxiliary information to be uniform,
and suffices for the security proofs of \cite{GGPR,PHGR}.
\end{remark}
The assumption roughly says the following: Suppose you've given me a bunch of group elements. Now you pick a uniform and independent $\alpha\in\F$, and for some subset $T$ of these 
elements, you now also given me the element $\alpha\cdot x$ for each $x\in T$. Suppose now I've generated a new pair of group elements of ratio $\alpha$; that is a pair
$(\enc{c},\enc{\alpha\cdot c})$. The $d$-PKE then says I must have constructed $c$ as a linear combination of the elements in $T$.
In the $d$-PKE $T=\sett{\enc{\tau^i}}{i\in[0..d]}$ for uniform $\tau\in\F$.
A natural extension would be to allow $T$ to be an arbitrary subset, which leads us to the $d$-LKE.
\begin{dfn}[$d$-Linear Knowledge of Exponent Assumption ($d$-LKE)]\label{dfn:linearkoeassumption}
Fix any efficient randomized circuit $C:\Gstar \to \G^{t}$ and a subset $S$ of size $d$ of $[t]$.
For any efficient \adv there exists an efficient \ext such that the following holds.
Consider the following experiment.
 $\alpha\in \F^*$ and $g\in \G$ are chosen uniformly.
 Denote $T\defeq \sett{C(g)_i}{i\in S}$
 \adv is given as input $C(g)$ and $\sett{\alpha\cdot x }{x\in T}$
 and outputs a pair of the form $(a,b)$ in $\Gstar$, which he ``hopes'' is of the form $(c,\alpha c)$.
   \ext, given the same input and the randomness of \adv, outputs  
 $a_1,\ldots,a_d \in \F$ such that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $b=\alpha\cdot a$. But,
  \item \ext ``failed'', i.e., $a \neq (\sum_{i=1}^d a_i \tau^i)\cdot g_1$.
   \end{enumerate}
is \neg.
\end{dfn}



We show that the $d$-LKE can be used to ``batch'' knowledge checks.

\begin{lemma}\label{lem:batchLKE}
Assuming the $d$-LKE the following holds. Fix $k=\poly$.
Fix any efficient randomized circuit $C:\G \to \G^{t}$ and subsets $S_1,\ldots,S_k$ of size at most $d$ of $[t]$.
Fix any $i\in [k]$.
For any efficient \adv there exists an efficient \ext such that the following holds.
Consider the following experiment.
 $\alpha_1,\ldots\alpha_k\in \F^*$ and $g\in \grouppair$ are chosen uniformly.
 Denote $T_j\defeq \sett{C(g)_i}{i\in S_j}$.
 \adv is given as input $C(g)$ and $\sett{\alpha\cdot x }{x\in T}$
 and outputs for some $\ell \in [k]$, a set of elements  $(a_1,\ldots, a_k,b)$ in $\Gstar$.
   \ext, given the same input as \adv together with the randomness of \adv and $\sett{\alpha_j}{j\in [k]\setminus\set{i}}$, outputs  
 $a_1,\ldots,a_d \in \F$ such that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $b=\sum_{j=1}^k\alpha_j\cdot a_j$. But,
  \item \ext ``failed'', i.e., $a_i \neq (\sum_{i=1}^d a_i \alpha_i)\cdot g_1$.
   \end{enumerate}
is \neg.
\end{lemma}
\begin{proof}
 Fix $k,C,\adv, S_1,\ldots,S_k$ and $i\in [k]$ as in the lemma. Assuming the $d$-LKE we aim to construct \ext satisfying the lemma statement. Consider the following efficient $\adv'$, that on input $C(g), T_i$ samples random \sett{\alpha_\ell\in \Fstar}{\ell\in [k]\setminus\set{i}},  computes $\sett{T_\ell}{\ell\in [k]\setminus\set{i}}$ and invokes \adv with
 uniformly chosen randomness \randadv on $C(g),T_1,\ldots,T_k$.
 When \adv returns $(a_1,\ldots,a_k,b)$, \advprime returns $(a_i,b')$ where
 \[b' = b-\sum_{\ell\in [k]\setminus\set{i}} \alpha_\ell\cdot a_\ell.\]
 Note that \adv succeeds exactly when \advprime succeeds in the sense that
 given any value of $C(g),\set{\alpha_\ell},\randadv$,
 \[\sum_{\ell\in [k]} \alpha_\ell\cdot a_\ell  = b \leftrightarrow \alpha_i\cdot a_i = b'\]
 Let \extprime be the extractor guaranteed to exist for $\advprime,C,T_i$ from the $d$-LKE.
 Note that the input for \extprime is $C(g),T_i$ together with the inner randomness of \advprime which is 
 $\randadv,\sett{\alpha_\ell}{\ell\in [k]\setminus\set{i}}$.
 
 Now define \ext to be the (identical) extractor that given 
 $(C(g),T_i,\randadv,\sett{\alpha_\ell}{\ell\in [k] \setminus\set{i}}$,
 simply returns the output $c_1,\ldots,c_d$ of \extprime on the same input.
\end{proof}



To simplify the proof we give an assumption that generalizes the $d$-SDH and $q$-PDH used in \cite{PHGR}, 
that we call the $d$-SPAN assumption
\begin{dfn}[d-SPAN]\label{dfn:spanassump}
 Fix integer $d$, and an $\F$-subspace $V$ of $\F(X)$ consisting only of polynomials of degree at most $d$.
 Let $B$ be a basis for $V$. Fix any efficient \adv, and consider the following game:
 Uniform $\tau\in \F$ and $g\in \G$ are sampled, and \adv is given \sett{f(\tau)}{f\in B}. Then the probability that \adv 
 outputs  $p,q\in \F(X)$ and $h\in \G$ such that
 \begin{enumerate}
  \item $\deg(p),\deg(q)\leq d$.
  \item $p/q \notin V$.
  \item $h= \enc{p(\tau)/q(\tau)}$
 \end{enumerate}
is \negl
\end{dfn}


\section{SNARK definitions}
We formally define zk-SNARKs.
We make a slightly non-conventional definition of knowledge soundness, where we allow the knowledge extractor access to
part of the CRS trapdoor.
%We deviate a bit in the definition of knowledge soundness, by giving the extractor access to part of the trapdoor.
\begin{dfn}\label{dfn:zkSNARK}
%Let \groupgen be a group generator for a prime field \F, and $\rel\subset \vecof{\F}$ a relation. 
An zk-SNARK \snark (zero-knowledge Succinct Non-interactive Argument of Knowledge) for a relation \rel consists of the following four possibly randomized algorithms.
\begin{enumerate}
 \item \gen outputting a pair of trapdoors $(\trapdoorext,\trapdoorsim)$ and common reference string \crs.
 \item \prv that takes as input \crs and $(\inp,\wit)\in \rel$ and outputs
 \prf.
 \item \ver that takes as input a common reference string \crs, an input \inp, and a proof \prf, and outputs a value in \set{\acc,\rej}.
 \item \simprv taking as input \inp, and trapdoor \trapdoorsim and outputting  \prf.
 (It will be convenient to think of \simprv as returning $(\inp,\prf)$.)
\end{enumerate}

The quadruple of algorithms $\snark = (\gen,\prv,\ver,\simprv)$ is a zk-SNARK for \rel if it satisfies

\begin{enumerate}
 \item \textbf{Completeness}: For any common reference string \crs output by \gen, and any $(\inp,\wit)\in \rel$, if $\prf = \prv(\crs,\inp,\wit)$; then
 $\ver(\crs,\inp,\prf) = \acc$ with probability one.
\item \textbf{Perfect Zero-Knowledge:} For any output $(\trapdoor,\crs)$ of \gen and $(\inp,\wit)\in \rel$, the distribution of $\simprv(\trapdoor,\inp)$
is identical to that of $\prv(\crs,\inp,\wit)$.

\item \textbf{Knowledge Soundness:}

For any efficient adversary \adv  making \poly steps, there exists an efficient  \ext of such that the following holds:
Suppose that \adv 
outputs a pair $(\inp,\prf)$ and \ext given \advrand and \trapdoorext,
outputs \wit.
The probability, over the randomness of \adv and that of \gen while outputting $((\trapdoorext,\trapdoorsim),\crs)$,
 that 
\begin{itemize}
 \item \adv ``wins'': $\ver(\inp,\prf,\crs)=\acc$, and
 \item \ext ``loses'': $(\inp,\wit)\notin \rel$
\end{itemize}
is \negl.
 \end{enumerate}
 
 \end{dfn}
 
\subsection{Description of our SNARK}\label{subsec:SNARK}
We assume familiarity with quadratic arithmetic programs.
See e.g., Section 2.3 in \cite{Groth16} for definitions.
We use similar notation to \cite{BCTV}, denoting by $m$ the size of the QAP, $d$ the degree and $n$ the number of public inputs.
More specifically, our QAP has the form \set{\sett{A_i(X),B_i(X),C_i(X)}{i\in [0..m]}, Z(X)}
where $A_i,B_i,C_i\in \F[X]$ have degree at most\footnote{\cite{BCTV} define $A_i,B_i,C_i$ to be of degree strictly less than $d$, however since $Z$ needs to be later added to \set{A_i},\set{B_i},\set{C_i} for zero-knowledge, it is more convenient for us to allow degree at most $d$ and assume $Z$ is already included. Note that in terms of the set of satisfiable instances $x\in \F^n$ every degree $d$ QAP is equivalent to one where \set{A_i,B_i,C_i} have degree smaller than $d$ obtained by taking the original polynomials mod $Z$.} $d$, and $Z\in \F[X]$ has degree exactly $d$.








We proceed to describe our proving system.
We assume we are already given a description of the groups $\G,\Gt$, the pairing $e$, and a uniformly chosen generator 
$g\in \G$, and these are all public.
\paragraph{\underline{Key Generation:}}

\begin{enumerate}
 \item Sample random $\tau,\alpha_A,\alpha_B,\alpha_C,\gamma,\beta\in \F^*$
 \item For $i\in [0..d]$ output $\pk_{H,i}\defeq \enc{\rho_A\rho_B \tau^i\cdot Z(\tau)}$
\item For $i\in [0..d]$ output $\pk'_{H,i}\defeq \enc{\alpha_C \rho_A\rho_B \tau^i\cdot Z(\tau)}$
 \item For $i\in [0..m]$ output
 
 \begin{enumerate}
  \item $\enc{\pk_{A,i}}\defeq \enc{\rho_A A_i(\tau)}$
  
\item $\enc{\pk_{B,i}}\defeq\enc{\rho_B B_i(\tau)}$,
\item $\enc{\pk_{C,i}}\defeq \enc{\rho_A\rho_B C_i(\tau)}$,

\end{enumerate}
 \item For $i\in [n+1..m]$ output
\begin{enumerate}
\item  $\enc{\pk'_{A,i}}\defeq\enc{\alpha_A\rho_A A_i(\tau)}$,
\item $\enc{\pk'_{B,i}}\defeq \enc{\alpha_B\rho_B B_i(\tau)}$,
\item $\enc{\pk'_{C,i}}\defeq \enc{\alpha_C \rho_A\rho_B C_i(\tau)}$
\item $\enc{\pk_{K,i}}\defeq \enc{\beta(\rho_A A_i(\tau) + \rho_B B_i(\tau) + \rho_A\rho_B C_i(\tau))}$ 

% \item $\pk_{K,i}\defeq \enc{\alpha_A\rho_A A_i(\tau)+\alpha_B\rho_B B_i(\tau)+\alpha_C \rho_A\rho_B C_i(\tau)+ \beta (\rho_A A_i(\tau) + \rho_B B_i(\tau) + \rho_A\rho_B C_i(\tau))}$ 

\end{enumerate}

\begin{remark}
 In fact it suffices to give the \emph{sum} of the $i$'th elements, instead of four separate ones, for the knowledge elements.
\end{remark}


\item Output the additional verification key elements $(\enc{\alpha_A},\enc{\alpha_B},\enc{\alpha_C},\enc{\gamma},\enc{\beta\gamma},\enc{\beta\gamma},\enc{\rho_A\rho_B Z(\tau)})$
 \end{enumerate}

\paragraph{\underline{Prover:}\\}
The prover has in his hand a QAP solution $(x_0=1,x_1,\ldots,x_m)$ that coincides with the public input $x=(x_1,\ldots,x_n)$ and satisfies the following:
If we define $A\defeq \sum_{i=0}^m x_i\cdot A_i, B\defeq \sum_{i=0}^m x_i \cdot B_i,$ and $C\defeq \sum_{i=0}^m x_i \cdot C_i$;
then the polynomial $P\defeq A\cdot B - C$ will be divisble by the target polynomial $Z$, and \per can compute the polynomial $H$ of degree at most $d$ with $P=H\cdot Z$. Let $\amid\defeq A -\sum_{i=0}^n x_i\cdot A_i$; define \midb and \midc analogously.

Given the proving key, \per computes as linear combinations of the proving key elements $\enc{\pi_A},\enc{\pi_B},\enc{\pi_C}$ $,\enc{\pi_H},\enc{\pi_K}$ where 
\begin{enumerate}
\item $\pi_A\defeq \rho_A \amid(\tau)$ .
\item $\pi_B\defeq \rho_B \midb(\tau)$.
\item $\pi_C\defeq \rho_A\rho_B \midc(\tau)$.
\item $\pi_H\defeq H(\tau)$.
\item $\pi_K\defeq \alpha_A \rho_A\mida(\tau) + \alpha_B \rho_B\midb(\tau) + \alpha_C\rho_A\rho_B(\midc(\tau)+ Z(\tau)H(\tau))$
$+ \beta(\rho_A\mida(\tau)+\rho_B\midb(\tau) + \rho_A\rho_B\midc(\tau))$.
\end{enumerate}
 and outputs $\prf = (\pi_A,\pi_B,\pi_C,\pi_K,\pi_H)$,
 

\paragraph{\underline{Verifier:}\\}
Denote the ``public input components'' 
\[ \PI(x) \defeq \pk_{A,0} + \sum_{i=1}^n x_i \pk_{A,i} = \enc{\rho_A A_0(\tau) + \sum_{i=1}^n x_i \rho_A A_i(\tau) }\]
\[ \PIb(x) \defeq  \rho_B B_0(\tau) + \sum_{i=1}^n x_i \rho_B B_i(\tau) \]
\[ \PIc(x) \defeq \rho_A\rho_B C_0(\tau) + \sum_{i=1}^n x_i \rho_A\rho_B C_i(\tau) \]

%  For an element $a$ of \G1 (\G2) denote by \dl{a} the discrete log of $a$ w.r.t $g_1(g_2)$.
 The verifier, using pairings and the verification key, checks the following.
\begin{enumerate}
\item $\pi_K =     \alpha_A\cdot \pi_A+ \alpha_B\pi_B+\alpha_C\cdot \pi_C+ \beta(\pi_A+\pi_B+\pi_C)$
.
\item $(\PI(x)+\pi_A)(\PIb(x)+\pi_B)= (\PIc(x)+\pi_C)+\rho_A\rho_B\cdot \pi_H Z(\tau)$.
 \end{enumerate}

 
 \section{Proof of knowledge soundness}
 Fix an efficient \adv. There exists an efficient \ext such that given \trapdoor,
 for any public input \inp, the probability that \adv outputs a verifying $(\inst,\inp,\prf)$, and $\ext(\inp,\randadv,\trapdoor)$
 doesn't output a witness \wit is \negl.
 \paragraph{Description of \ext}
 Suppose that \adv has constructed a verifying proof $\enc{\pi_A},\enc{\pi_B},\enc{\pi_C},\enc{\pi_H},\enc{\pi_K}$ for public input \inp.
 
 In particular, we have
 \[\alpha_A \pi_A + \alpha_B \pi_B + \alpha_C\pi_C+  \beta(\pi_A + \pi_B + \pi_C) = \pi_K\]
 
 This is implies by Lemma \ref{lem:batchLKE} that given $\alpha_B,\alpha_C,\beta\in \trapdoor$
 and \advrand, \ext can extract e.w.p. \negl coefficients $a_1,\ldots,a_m$ such that
 \[\pi_A = \sum_{i= n+1}^m a_i\cdot \rho_A  A_i(\tau)\]
 \ext outputs $(a_{n+1},\ldots,a_m)$ as the candidate witness for public input $\inp=(a_1,\ldots,a_n)$.
 
 Let $\gamma$ be the probability that \adv outputs a validating $(\inst,\inp,\prf)$ with \inst of degree $d$ but 
 \ext doesn't output a valid witness \wit for $(\inst,\inp)$ we show an efficient \advv
 that solves $D$-span for $D=4d+4$ with probability $\gamma-\negl$ thus implying $\gamma=\negl$ under $D$-span.
 
 Denote $q\defeq 4(d+1)$
 
 Challenge recieved: \sett{\tau^i}{i\in\set{0\ldots,q,q+2,\ldots,2q}}
 now choose random $\rho'_A,\rho'_B$
 Set $\rho_A\defeq \rho'_A\tau^{d+1}, \rho_B\defeq \rho'_B\tau^{2(d+1)}$
 Choose random $\alpha_A,\alpha_B,\alpha_C\in\Fstar$ \ariel{\Fstar easier than \F cause harder to get $\beta$ uniform in \F}.
 For $i\in [n+1..m]$, define the following set of polynomial  $R_i(X)\in\F[X]$ by 
 \[R_i(X)\defeq \rho'_A X^{d+1} A_i(X) + \rho'_BX^{2(d+1)} B_i(X) + \rho'_A\rho'_B X^{3(d+1)} C_i(X)\]
 Let $V=\span \sett{R_i(X)}{i\in [n+1..m]}$.
 Let $U$ be the space of polynomials $f\in\F[X]$ of degree at most $q= 4(d+1)$ such that for each $i\in[n+1..m]$,
 $R_i\cdot f$ has a zero coefficient at $X^{q+1}$. $U$ contains non-zero elements according to Lemma 10 in \cite{GGPR}
 Choose uniform $f\in U\in\setminus\set{0}$ and let $\beta\defeq f(\tau)$. Note that $\beta$ is uniformly distributed and independent of $\tau$,
 as we can sample uniform non-zero $f\in U$ by sampling  unifrom non-zero $f'\in U$ and then choosing $f=c\cdot f'\in U$ for uniform $c\in \Fstar$.
 
 Now let $\enc{\pi_A},\enc{\pi_B},\enc{\pi_C},\enc{\pi_H},\enc{\pi_K}$ be the verifying proof \adv has constructed
 for $(\inst,\inp)$.
 Let $\ext_1,\ldots,\ext_4$ be the extractors guaranteed to exist from Lemma \ref{lem:batchLKE}
 that when supplied with $\randadv,\alpha_A,\alpha_B,\alpha_C,\beta$ will output e.w.p \negl
 coefficients  \sett{a_i,b_i,c_i,k_i}{i\in [n+1..m]} such that
 \[\pi_A =\sum_{i= n+1}^m a_i\cdot \rho_A  A_i(\tau),\pi_B = \sum_{i= n+1}^m b_i\cdot \rho_B  B_i(\tau),
  \pi_C = \sum_{i= n+1}^m c_i\cdot \rho_A\rho_B  C_i(\tau), \pi_A+\pi_B+\pi_C = \sum_{i= n+1}^m k_i\cdot (\rho_A  A_i(\tau)+ \rho_B B_i(\tau) + \rho_C C_i(\tau)
 \]
If one of the four extractors failed \advv aborts.
Define $\amid \defeq \sum_{i= n+1}^m a_i\cdot   A_i,\bmid \defeq \sum_{i= n+1}^m b_i\cdot B_i,
\cmid \defeq \sum_{i= n+1}^m c_i\cdot C_i, R\defeq \sum_{i= n+1}^m k_i\cdot R_i $
and 
\[P\defeq (\abase+\amid)(\bbase+\bmid)-(\cbase+\cmid)\]
 Suppose \ext failed.
 This means that $a_{n+1},\ldots,a_m$ is not a valid QAP witness for $a_1,\ldots,a_n$.
We claim there are only two cases where this happens.
Define 
\[R'\defeq \rho_A \amid + \rho_B \bmid + \rho_A\rho_B \cmid\]
\begin{enumerate}
 \item $R'\notin V$.
 \item $P(X)$ is not divisble by $Z(X)$
\end{enumerate}

Suppose $R'\in V$. Hence there exist coefficients $\sett{x_i}{i\in [n+1..m]}$ such that
\[\rho'_A X^{d+1} \amid + \rho_B X^{2(d+1)} \bmid + \rho_A\rho_B X^{3(d+1)}\cmid = \sum_i x_i\cdot (\rho'_A X^{d+1} A_i(X) + \rho'_BX^{2(d+1)} B_i(X) + \rho'_A\rho'_B X^{3(d+1)} C_i(X))\]
Degree conditions imply $\amid = \sum_i x_i A_i,\bmid =\sum_i x_i B_i, \cmid = \sum_i x_i C_i$.
%If $\set{a_i}=\set{b_i}=\set{c_i}$ 
Since also $Z$ divides $P$ we have by definition that $x_{n+1},\ldots,x_m$  is a valid witness for $a_1,\ldots,a_n$.

We show, on the other hand, that if one of the two conditions above doesn't hold and \advv hasn't aborted so far,
then \advv has a valid solution to the $D$-span challenge where $D=2q$ and the subspace $V$ is $\span(1,X,\ldots,X^q,X^{q+2},\ldots,X^{2q})$.
Suppose the first condition doesn't hold.
Denote by $\eta$ the probability that the coefficient of $X^{q+1}$ in $R\cdot f$ is non-zero.
Think of a party $B$ that recieves $(f(\tau),\tau)$ computes the rest of the CRS as \advv does here and then gives the challenge to \adv
that w.p. $\eta$ returns a polynomial $R'$ of degree at most $3d+3$ such that $R'\cdot f$ has zero coefficient for $X^{q+1}$ but is not in $V$.
Lemma 10 of \cite{GGPR} tells us $\eta\leq 1/|\F|$.
Otherwise, as any polynomial with a non-zero coefficient for $X^{q+1}$ is not in $V$,\ advv can output $(R\cdot f,1,\enc{\pi_K})$ as a solution
to $D$-span.
In the second case $P/Z$ is not a polynomial. Recall that $\pi_H/(\rho_A\rho_B)=P(\tau)/Z(\tau)$ as the verification equations hold.
Thus, \advv can output $(P,Z,\enc{\pi_H}/(\rho_A\rho_B))$ as a solution to $D$-span.                                                                
Hence we have that the success probability of \advv is at least $\gamma-\negl-1/|\F|=\gamma-\negl$.
 
%\section*{Acknowledgements}
\bibliographystyle{alpha}
\bibliography{References}

\end{document}
 
