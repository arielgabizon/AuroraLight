\def\notes{1}
\documentclass[11pt]{article}
%\usepackage[T1]{fontenc}
%\usepackage[letterpaper]{geometry}
%\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
%\usepackage{verbatim}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
%\usepackage{setspace}
\usepackage{xspace}%,enumitem}
%\usepackage{times}
\usepackage{fullpage}
%\usepackage{hyperref}
%\doublespacing
\usepackage{color}
\usepackage{numdef}
\usepackage{enumitem}
\usepackage{amsopn}
%\usepackage{hyperref} 

\providecommand{\sqbinom}{\genfrac{\lbrack}{\rbrack}{0pt}{}}
\DeclareMathOperator{\spn}{span}

\newif\ifdraft
%\drafttrue
\draftfalse
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
%\numberwithin{equation}{section} %% Comment out for sequentially-numbered
\numberwithin{figure}{section} %% Comment out for sequentially-numbered
\newtheorem{thm}{Theorem}[section]
\newtheorem{conjecture}[thm]{Conjecture}
\newtheorem{definition}[thm]{Definition}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{remark}[thm]{Remark}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{claim}[thm]{Claim}
\newtheorem{fact}[thm]{Fact}
\newtheorem{openprob}[thm]{Open Problem}
\newtheorem{remk}[thm]{Remark}
\newtheorem{example}[thm]{Example}
\newtheorem{apdxlemma}{Lemma}
\newcommand{\question}[1]{{\sf [#1]\marginpar{?}} }
%\usepackage{babel}
\usepackage{tikz}

\makeatletter
\newcommand*{\circled}{\@ifstar\circledstar\circlednostar}
\makeatother

\newcommand*\circledstar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      fill,
      circle,
      minimum size=1.35em,
      text=white,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}
\newcommand*\circlednostar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      draw,
      circle,
      minimum size=1.35em,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}

\providecommand{\bd}[1]{\circled{#1}}


%Eli's macros
\newcommand{\E}{{\mathbb{E}}}
%\newcommand{\N}{{\mathbb{N}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\calF}{{\cal{F}}}
%\newcommand{\inp}[1]{\langle{#1}\rangle}
\newcommand{\disp}[1]{D_{#1}}
%\newcommand{\spn}[1]{{\rm{span}}\left(#1\right)}
%\newcommand{\supp}{{\rm{supp}}}
\newcommand{\agree}{{\sf{agree}}}
\newcommand{\RS}{{\sf{RS}}}
\newcommand{\aRS}{{\sf{aRS}}}
\newcommand{\rrs}{R_{\aRS}}
\newcommand{\VRS}{V_\RS}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\angles}[1]{\langle{#1}\rangle}
\newcommand{\condset}[2]{\set{#1 \mid #2 }}
\newcommand{\zo}{\set{0,1}}
\newcommand{\zon}{{\zo^n}}
\newcommand{\zom}{{\zo^m}}
\newcommand{\zok}{{\zo^}}
\newcommand{\eps}{\epsilon}
\newcommand{\e}{\eps}
%\newcommand{\d}{\delta}
\newcommand{\poly}{{\rm{poly}}}
\newcommand{\itone}{{\it{(i)}}\xspace}
\newcommand{\ittwo}{{\it{(ii)}}\xspace}
\newcommand{\itthree}{{\it{(iii)}}\xspace}
\newcommand{\itfour}{{\it{(iv)}}\xspace}
\newcommand{\cc}{{\rm{CC}}}
\newcommand{\rnk}{{\rm{rank}}}
\newcommand{\T}{T}
\newcommand{\I}{{\mathbb{I}}}
\ifdraft
\newcommand{\ariel}[1]{{\color{blue}{\textit{#1 --- ariel gabizon}}}}
\else
\newcommand{\ariel}[1]{}
\fi
\providecommand{\improvement}[1]{{\color{red} \textbf{#1}}}
\title{%
On the size of pairing based proofs under Knowledge of Exponent}
\date{\today}
\author{Ariel Gabizon}
\date{Zcash}
\begin{document}
\maketitle
 \mathchardef\mhyphen="2D

%\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}

%\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{A}\xspace}
\newcommand{\advprime}{\ensuremath{A'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}

\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2

\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\A}{\ensuremath{\vec{A}}\xspace}
\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}

%\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
%\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}

\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\inp}{\ensuremath{x}\xspace}
\newcommand{\wit}{\ensuremath{\omega}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{V}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{P}}\xspace}

\newcommand{\prf}{\ensuremath{\pi}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{B}\xspace} % the adversary that uses protocol adversary as black box
\renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\log r)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathcal R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\begin{abstract}
We investigate how efficient a SNARK can be when using only a ``linear'' knowledge assumption rather than a quadratic one.
We present a simple lemma to ``batch'' knowledge checks that allows us to batch 4 elements of the Pinocchio proof system into one. As a result we get a proofs with 5 group elements under very similar assumptions to \cite{PHGR}.
\end{abstract}

\section{Introduction}
The most efficient known proving systems with succinct proofs rely on very strong cyrptographic assumptions, sometimes called non-falsifiable. This was shown to be necessary. However, one would naturally want to minimize the strength of the assumptions made. The most efficient known proving system, requiring only three group element proofs was designed by Groth \cite{Groth16}. It's security is proven in the ``Generic Group Model'' in which all used non-falsifiable assumptions hold. The model implies, at least when the CRS elements are of low degree, that all the malicious prover can do is take a non-adaptive linear combination of the key elements.
Previous proving systems \cite{GGPR, PHGR} relied on the \emph{d-power knowledge of exponent assumption:}

\begin{dfn}[$d$-Power Knowledge of Exponent Assumption ($d$-PKE)]\label{dfn:koeassumption}
For any efficient \adv there exists an efficient \ext such that the following holds.
Fix an efficient  randomized circuit $S$ with input domain $(\grouppair)^{2(q+1)}$.
 Consider the following experiment.

 $\tau,\alpha\in \F^*$ and $g\in \grouppair$ are chosen uniformly. We denote $V\defeq \koevec{\tau}{d}\cdot g$
 Then \adv is given as input $(V,S( V))$;
 and outputs a pair of the form $(c,d)$ in $\G11$, which he ``hopes'' is of the form $(c,\alpha c)$.
   \ext, given the same input, outputs  
 $a_0,a_1,\ldots,a_q \in \F$ such that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $c=\alpha\cdot b$. But,
  \item \ext ``failed'', i.e., $c \neq (\sum_{i=0}^q a_i \tau^i)\cdot g_1$.
   \end{enumerate}
is \neg.
 The same holds when \G11 is replaced by \G21 and $g_1$ is replaced by $g_2$.
\end{dfn}
\begin{remark}
Typically the PKE assumption is defined with auxiliary information rather than a randomized circuit.
Our definition is weaker since it roughly corresponds to imposing the auxiliary information to be uniform,
and sufficed for the security proofs of \cite{GGPR,PHGR}.
\end{remark}
\subsection{Description of our SNARK}\label{subsec:SNARK}
We assume familiary of quadratic arithmetic programs.
See e.g., Section 2.3 in \cite{groth16} for definitions.
We use similar notation to \cite{BCTV}, denoting by $m$ the size of the QAP, $d$ the degree and $n$ the number of public inputs.
More specifically, our QAP has the form \set{\sett{A_i(X),B_i(X),C_i(X)}{i\in [0..m]}, Z(X)}
where $A_i,B_i,C_i\in \F[X]$ have degree at most\footnote{\cite{BCTV} define $A_i,B_i,C_i$ to be of degree strictly less than $d$, however since $Z$ needs to be later added to \set{A_i},\set{B_i},\set{C_i} for zero-knowledge, it is more convenient for us to allow degree at most $d$ and assume $Z$ is already included. Note that in terms of the set of satisfiable instances $x\in \F^n$ every degree $d$ QAP is equivalent to one where \set{A_i,B_i,C_i} have degree smaller than $d$ obtained by taking the original polynomials mod $Z$.} $d$, and $Z\in \F[X]$ has degree exactly $d$.



\begin{dfn}[$d$-Linear Knowledge of Exponent Assumption ($d$-LKE)]\label{dfn:koeassumption}
Fix any efficient randomized circuit $C:\Gstar \to \G^{t}$ and a subset $S$ of size $d$ of $[t]$.
For any efficient \adv there exists an efficient \ext such that the following holds.
Consider the following experiment.
 $\alpha\in \F^*$ and $g\in \G$ are chosen uniformly.
 Denote $T\defeq \sett{C(g)_i}{i\in S}$
 \adv is given as input $C(g)$ and $\sett{\alpha\cdot x }{x\in T}$
 and outputs a pair of the form $(a,b)$ in $\Gstar$, which he ``hopes'' is of the form $(c,\alpha c)$.
   \ext, given the same input and the randomness of \adv, outputs  
 $a_1,\ldots,a_d \in \F$ such that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $b=\alpha\cdot a$. But,
  \item \ext ``failed'', i.e., $a \neq (\sum_{i=1}^d a_i \tau^i)\cdot g_1$.
   \end{enumerate}
is \neg.
\end{dfn}


We show that the $d$-LKE can be used to ``batch'' knowledge checks.

\begin{lemma}\label{lem:batchLKE}
Assuming the $d$-LKE the following holds.
Fix any efficient randomized circuit $C:\G \to \G^{t}$ and $k$ subsets $S_1,\ldots,S_k$ of size at most $d$ of $[t]$.
Fix any $i\in [k]$.
For any efficient \adv there exists an efficient \ext such that the following holds.
Consider the following experiment.
 $\alpha_1,\ldots\alpha_k\in \F^*$ and $g\in \grouppair$ are chosen uniformly.
 Denote $T_j\defeq \sett{C(g)_i}{i\in S_j}$
 \adv is given as input $C(g)$ and $\sett{\alpha\cdot x }{x\in T}$
 and outputs for some $\ell \in [k]$, a set of elements  $(a_1,\ldots, a_k,b)$ in $\Gstar$.
   \ext, given the same input as \adv together with the randomness of \adv and $\sett{\alpha_j}{j\in [k]\setminus\set{i}}$, outputs  
 $a_1,\ldots,a_d \in \F$ such that the probability that both
   
 \begin{enumerate}
  \item \adv ``succeeded'', i.e., $b=\sum_{j=1}^k\alpha_j\cdot a_j$. But,
  \item \ext ``failed'', i.e., $a_i \neq (\sum_{i=1}^d a_i \alpha_i)\cdot g_1$.
   \end{enumerate}
is \neg.
\end{lemma}
\begin{proof}
 Fix $C,\adv, S_1,\ldots,S_k$ and $i\in [k]$ as in the lemma statement. We aim to construct \ext satisfying the lemma statement. Consider the following efficient $\adv'$, that on input $C(g), T_i$ samples random \sett{\alpha_\ell\in \Fstar}{\ell\in [k]\setminus\set{i}}  computes $\sett{T_\ell}{\ell\in [k]\setminus\set{i}}$ and invokes \adv with
 uniformly chosen randomness \randadv on $C(g),T_1,\ldots,T_k$.
 When \adv returns $(a_1,\ldots,a_k,b)$, \advprime returns $(a_i,b')$ where
 \[b' = b-\enc{\sum_\ell \alpha_\ell\cdot a_\ell}.\]
 Note that \adv succeeds exactly when \advprime succeeds in the sense that
 given any value of $C(g),\set{\alpha_\ell},\randadv$,
 \[\sum_\ell \alpha_\ell a_\ell  = b \leftrightarrow \alpha_i a_i = b'\]
 Let \extprime be the extractor guaranteed to exist for $\advprime,C,T_i$ from the $d$-LKE.
 Note that the input for \extprime is $C(g),T_i$ together with the inner randomness of \advprime which is 
 $\randadv,\sett{\alpha_\ell}{\ell\in [k]\setminus\set{i}}$.
 
 Now define \ext to be the (identical) extractor that given 
 $(C(g),T_i,\randadv,\sett{\alpha_\ell}{\ell\in [k] \setminus\set{i}}$.
 simply returns the output $c_1,\ldots,c_d$ of \extprime on the same input.
\end{proof}



We proceed to describe our proving system.
We assume we are already given a description of the groups $\G,\Gt$, the pairing $e$, and a uniformly chosen generator 
$g\in \G$, and these are all public.
\paragraph{\underline{Key Generation:}}

\begin{enumerate}
 \item Sample random $\tau,\alpha_A,\alpha_B,\alpha_C,\gamma,\beta\in \F^*$
 \item For $i\in [0..d]$ output $\pk_{H,i}\defeq \enc{\rho_A\rho_B \tau^i\cdot Z(\tau)}$
\item For $i\in [0..d]$ output $\pk'_{H,i}\defeq \enc{\alpha_C \rho_A\rho_B \tau^i\cdot Z(\tau)}$
 \item For $i\in [0..m]$ output
 
 \begin{enumerate}
  \item $\pk_{A,i}\defeq \enc{\rho_A A_i(\tau)}$
  
\item $\pk_{B,i}\defeq\enc{\rho_B B_i(\tau)}$,
\item $\pk_{C,i}\defeq \enc{\rho_A\rho_B C_i(\tau)}$,

\end{enumerate}
 \item For $i\in [n+1..m]$ output
\begin{enumerate}
\item  $\pk'_{A,i}\defeq\enc{\alpha_A\rho_A A_i(\tau)}$,
\item $\pk'_{B,i}\defeq \enc{\alpha_B\rho_B B_i(\tau)}$,
\item $\pk'_{C,i}\defeq \enc{\alpha_C \rho_A\rho_B C_i(\tau)}$
\item $\pk_{K,i}\defeq \enc{\beta(\rho_A A_i(\tau) + \rho_B B_i(\tau) + \rho_A\rho_B C_i(\tau))}$ 

% \item $\pk_{K,i}\defeq \enc{\alpha_A\rho_A A_i(\tau)+\alpha_B\rho_B B_i(\tau)+\alpha_C \rho_A\rho_B C_i(\tau)+ \beta (\rho_A A_i(\tau) + \rho_B B_i(\tau) + \rho_A\rho_B C_i(\tau))}$ 

\end{enumerate}



\item Output the additional verification key elements $(\enc{\alpha_A},\enc{\alpha_B},\enc{\alpha_C},\enc{\gamma},\enc{\beta\gamma},\enc{\beta\gamma},\enc{\rho_A\rho_B Z(\tau)})$
 \end{enumerate}

\newcommand{\amid}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\paragraph{\underline{prover:}\\}
The prover has in his hand a QAP solution $(x_0=1,x_1,\ldots,x_m)$ that coincides with the public input $x=(x_1,\ldots,x_n)$ and satisfies the following:
If we define $A\defeq \sum_{i=0}^m x_i\cdot A_i, B\defeq \sum_{i=0}^m x_i \cdot B_i,$ and $C\defeq \sum_{i=0}^m x_i \cdot C_i$;
then the polynomial $P\defeq A\cdot B - C$ will be divisble by the target polynomial $Z$, and \per can compute the polynomial $H$ of degree at most $d$ with $P=H\cdot Z$. Let $\amid\defeq A -\sum_{i=0}^n x_i\cdot A_i$; define \midb and \midc analogously.

Given the proving key, \per computes as linear combinations of the proving key elements
\begin{enumerate}
\item $\pi_A\defeq \enc{\rho_A \amid(\tau)}$, $\pi'_A\defeq \enc{\alpha_A\rho_A \amid(\tau)}$.
\item $\pi_B\defeq \enc{\rho_B \midb(\tau)}$, $\pi'_B \defeq \enc{\alpha_B\rho_B \midb(\tau)}$.
\item $\pi_C\defeq \enc{\rho_A\rho_B \midc(\tau)}$, $\pi'_C \defeq \enc{\alpha_C\rho_A\rho_B \midc(\tau)}$.

\item $\pi_K\defeq \enc{\beta(\rho_A A(\tau) + \rho_B B(\tau) + \rho_A\rho_B C(\tau))}$.
\item $\pi_H\defeq \enc{H(\tau}$.
\item $\pi_K\defeq [\alpha_A \rho_A\mida(\tau) + \alpha_B \rho_B\midb(\tau) + \alpha_C\rho_A\rho_B(\midc(\tau)+ Z(\tau)H(\tau))$
$+ \beta(\rho_A\mida(\tau)+\rho_B\midb(\tau) + \rho_A\rho_B\midc(\tau))]$.
\end{enumerate}
 and outputs $\prf = (\pi_A,\pi_B,\pi_C,\pi_K)$,
 

\paragraph{\underline{\bctv verifier:}\\}
Denote the ``public input component'' 
\[ \PI(x) \defeq \pk_{A,0} + \sum_{i=1}^n x_i \pk_{A,i} = \enc{\rho_A A_0(\tau) + \sum_{i=1}^n x_i \rho_A A_i(\tau) }\]
%  For an element $a$ of \G1 (\G2) denote by \dl{a} the discrete log of $a$ w.r.t $g_1(g_2)$.
 The verifier, using pairings and the verification key, checks the following.
\begin{enumerate}
\item $e(\pi_K,g_2)= e(\pi_A,\enc{\alpha_A+\beta})\cdot e(\enc{\alpha_B+\beta},\pi_B)\cdot e(\pi_C,\enc{\alpha_C+\beta})\cdot$
e()$.
\item $e(\PI(x)+\pi_A,\PIb(x)\pi_B)= e(\PIc(x)+pi_C,g_2)$.
 \end{enumerate}
 
 
\section*{Acknowledgements}
We thank Sean Bowe for useful discussions and a review of this note.
\bibliographystyle{alpha}
\bibliography{References}

\end{document}
 
